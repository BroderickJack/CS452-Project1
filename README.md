# CS452-Project1
Game created using WebGL for CS452 - Computer Graphics
Jack Broderick & Alison Davis

Wack-A-Shape

Game Controls Description:
Wack-A-Shape is a simulation of Wack-A-Mole where the user is attempting to "wack", or in this case click, a specific shape before it disappears. The faster the user clicks the specified shape, the more points they are awarded. The desired shape to click is shown in the black box on the left-hand side of the screen. Clicking the right shape and color as the target shape as quickly as possible after the shape shows up awards the player the maximum number of points. Clicking the right shape in the wrong color gives the user half of the points that would normally be awarded. Clicking the wrong shape in any color results in the loss of the number of points that would have been awarded had it been the correct shape. Missing a shape and clicking the canvas causes the user to lose 20 points per click, so accuracy is important. You may get points for clicking multiple correct versions of the same target shape before it changes. It is also possible that the target shape will change before a matching shape is clicked, so be sure to watch out!! The user wins by surpassing a score of 1,500. The user loses if they drop below -500 points.

Game Implementation:

Game Initialization-
The game shapes consist of 6 polygons: a triangle, diamond, pentagon, octagon, circle, and ellipse. These shapes may also come in three different colors: red, green, or blue. A different function is used to create and return each of the 6 shapes, whose initial points are centered at the origin. The array of points and a list of the x coordinates of the vertices and the y coordinates of the vertices are all assigned to the specific shape objects and scaled according to the elongated canvas. The x and y vertex lists are used for checking if clicks fall within the bounds of the shape. The game code consists of an array called shapeFunctions[ ]. This is an array of the 6 functions that create and return each of the 6 shapes. In order to translate the shapes, another array is initialized. This array is called slot_translations and contains 6 vectors, each vector made up of 2 floats: translations in the x and y. These 6 translations are the different slots in which the shapes to be "wacked" may appear in. There is also an array called shapes[ ] that is initialed with 6 null values. This array will either hold null or a shape object for each of the 6 slots. Finally there is an array of colors called COLORS[ ] which contains three vectors, each vector made up of 4 floats. At the end of the initialization, a loop of the renderShapes( ) function is started which is repeated every 15 ms.

Repeated Rendering-
The renderShapes( ) function first calls for the drawing of the "target shape." This is the shape that the player can get points for clicking. A new target shape is generated every 4.5 seconds (every 300th time the renderShapes( ) function is run, regardless of if the previous target shape had been found yet or not. This target shape is generated at random and is equally likely to be any of the 6 polygons, in any of the 3 colors. It is also drawn inside of a box that uses gl.LINE_LOOP to identify it as separate from the shapes that can be clicked. Upon each call of the renderShapes( ) function, the generateShapes( ) function is also called.

generateShapes( ) function:
Upon each call of this function, each slot has the chance to be filled if it is empty. First it is checked if the slot is empty. If that is the case, then there is a 1/100 chance at random that the slot will now get filled. With this being called about 67 times per second, per slot, it is more likely than not that a slot will take on a random shape within a second of being empty. If by chance it is decided that the current slot must be filled, a randomly generated number in the range [0.0, 1.0) using Math.random( ) will also be multiplied by the length of the number of shapes minus one (i.e. 5) and then rounded. This is equally likely to randomly result in 0, 1, 2, 3, 4, or 5. This becomes the index of what shape to draw in the slot currently being filled. The current slot in the shapes[ ] array is now filled with this shape by calling for the creation of the shape from its "get function" in the shapeFunctions[ ] array. This method is used instead of pre-saving an array of the shapes themselves to avoid having to make deep-copies of pre-existing shapes. Instead, an entirely new shape object is generated each time a new shape is needed. The shape's x and y coordinates are translated by the corresponding x, y translations from the slot_translations[ ] array for the slot currently being filled. The translations are performed this way and not using matrices in the .html file because the transformations also needed to be performed on the list of x and y vertices that get checked in the checkShape( ) function to see if click events are within the bounds of the shape. Since this also must happen in the .js file, this type of transformation made more sense. The shape object is also assigned a maximum amount of time to show to the screen. This can be anywhere from 1 to 5 seconds but is assigned according to the rounding off of Math.random( ) times (MAX_TIME - MIN_TIME) + MIN_TIME. Finally, a randomly selected color is chosen in the same way, using a randomly generated number in the range [0.0, 1.0) using Math.random( ) and multiplying by the length of the array COLORS minus 1 (i.e. 2) and then rounded. This is equally likely to result in 0, 1, or 2. The random shape and its corresponding random color is correlated to the position being filled in the shapes[ ] array.

After generateShapes( ) control is returned to the renderShapes( ) function. There is a loop that iterates over the shapes[ ] array, rendering each of the shapes if the element in shapes[ ] is not null using gl.TRIANGLE_FAN. Each shape keeps track of a frame count, and on each iteration of renderShapes( ), it is checked if ((this frame count) * 15ms)/1000 s) > max time for the shape. This tells if the time that the shape has been showing in seconds is greater than the max time that was randomly assigned as 1, 2, 3, 4, or 5 in generateShapes( ) has been exceeded. If it has, the shape is set to null and will therefore not be rendered again on the next run through. The corresponding slot in shapes[ ] is returned to null and thus goes back to having the chance to be filled at random when generateShapes( ) runs.

User Input-
The only possible user input that the game is designed to handle are mouse clicks. Each mouse click calls the function checkBounds( ) with the click event as argument. This function takes the coordinates of the click event and converts them from canvas coordinates to viewport coordinates. These converted coordinates are then fed to the checkShape( ) function as arguments, one-by-one with each of the non-null elements of the shapes[ ] array (all of the shapes currently existing in any of the 6 slots). The checkShape( ) function uses the scaled and translated vertices of the shape that it is given to see if the converted x,y coordinates from the click event fall within the bounds of the shape. If the click is within the shape, points are then either awarded or subtracted based on whether or not the shape is the same shape-type and color as the target shape. Shape type is determined by comparing number of vertices, colors are compared directly. Same shape and color is worth the most points at a value of ((s.max_time / MS_FRAME) * 1000) - s.frameCount. This means that it takes the maximum time the shape is showing, divided by 15 ms for how long a frame shows, and multiplies it by 1000. It then subtracts how many frames the shape had already been showing for. This awards points for all of the remaining frames the shape could have been showing had the user not clicked it. It thus incentivizes clicking shapes faster to earn more points. If only the shape matches, but not the color, then 1/2 of this value of points is added. If the shape is not the right shape at all, regardless of color, 1/2 of this value of points is subtracted. The checkBounds function returns true if the click is within a shape and false if it is not. This allows the checkBounds function to determine if any shape at all is clicked. If the click is outside of the bounds of any shape, then 20 points are subtracted automatically. The scoreboard above the gameplay canvas is updated in the checkShape( ) function as well.

Win Condition-
When the score exceeds 1000, gameplay stops and the user is informed that he/she won. If the user hits -500 at any point, gameplay also stops and the user is informed that he/she lost. The score is shown at the top of the screen.
